import Data.Typeable

main :: IO ()
main = do
    -- ☆ 型について
    putStrLn (show (typeOf 'a'))   -- 出力はChar
    putStrLn (show (typeOf "aaa")) -- 出力は[Char]
    -- 'で囲うと文字になり"で囲うと文字列として認識される模様
    -- ちなみにCLIでghci って入力して対話モードに入り
    -- :t 'a' って打つと
    -- 'a' :: Char が返ってくる（型は大文字から始まる）

    -- ☆ 型と型クラス
    putStrLn (show ('a' == 'a'))
    -- 当然ながらTrueが返ってくる
    -- ghciで :t (==) って打つと関数の型が確認できる
    -- 出力は (==) :: Eq a => a -> a -> Bool
    -- 小文字のaは型変数と呼び、どんな型でも取りうる、つまり任意の引数を2つとってBool型の引数を返す
    -- （余談だが型変数を引数に取る関数を多相的関数と呼ぶらしい）
    -- Eq a => ってのは型クラス制約であり、aは型クラスEqのインスタンスでないといけない
    -- ↑は厳密にいうと、（型クラスEqのインスタンスであれば）任意の引数を2つとってBool型の引数を返す ってなる
    -- では型クラスとは何か OOP的なクラスではない、正体はただの関数群である
    -- 例えばEq型クラスは「==」と「/=」、Ord型クラスは「>」とか「>=」だったりする
    -- Eq型クラスの関数に任意の型を渡した時、その挙動が定義されていればその型はEq型クラスのインスタンスになる
    -- 例えばInt型はEq型クラスのインスタンスでもあるし、Ord型クラスのインスタンスでもある

    -- ☆ 型注釈
    let hoge = read "4" :: Int
    -- let hoge = read "4" とかやると失敗する 何故か？
    -- read関数は文字列を引数にread型クラスのインスタンスを返すが、IntとFloatが両方とも該当している
    -- 型推論がそこまで利口でなく、どちらの型で返せばいいのかわからないのでIntで返せと指定している
    putStrLn (show hoge)